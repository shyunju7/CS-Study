### 🔥 CPU 스케쥴러
---
→ 다중 프로그램 운영제체의 기본으로, 
    운영체제는 CPU를 프로세스 간에 교환함으로써 더 생산적으로 관리함

→ 다중 프로그래밍의 목적은 `CPU 이용률`을 최대화하는 것

→ 준비 큐에 있는 프로세스 중 하나를 선택해 실행하는 주체

<br/>

### 👉 선점 스케쥴러 VS 비선점 스케쥴러

```jsx
선점 → CPU를 프로세스 우선순위에 따라 강제로 빼앗아 CPU 회수
비선점 → CPU가 프로세스에 할당되면 프로세스 종료나 대기 상태로 전환되기 전까지 CPU 점유
```

<br/>

### 🔥 비선점 스케쥴링 알고리즘

---

**1) 선입 선처리 알고리즘 (FCFS, First Come First Seved Scheduling) = FIFO**

→ 프로세스가 준비 큐에 도착한 순서대로 CPU를 할당하는 방식

→ 단점) 평균 대기시간이 길어질 수 있음 (→ 대화형 시스템에 적합하지 않음)

→ 전체 프로세스들의 평균 대기시간이 늘어나는 현상 (⇒ 콘보이 현상) 발생

<br/>

**2) 최단 작업 우선 스케쥴링 (SJF, Shortest Job First Scheduling)**

→ CPU 작업 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당

→ 평균 대기 시간을 가장 짧게 가지는 최적의 알고리즘이지만, 실제 적용엔 무리 
    (⇒ 실제 실행 시간(CPU Burst)를 알 수 없음)

→ 가장 긴 작업 시간을 가진 프로세스에게 CPU를 할당해주지 못하는 현상 (⇒ 기아 현상) 발생 가능

```jsx
++ 선점형 방식으로 구현된 SJF → `SRTF(Shortest Remain Time First)`
→ 더 짧은 작업 시간을 가진 프로세스가  도착한다면, CPU를 빼앗아 할당 
→ 가장 최소한의 대기시간을 보장
```

<br/>

**3) HRN (Highest Response-ratio Next)**

→ SJF 방식에 기아현상을 해결하기 위해 `Aging`기법을 적용한 비선점 방식

→ 우선순위  = (대기시간 + 실행시간) / 실행시간 (대기시간이 Aging 역할)

    계산된 우선순위 수치가 높을수록 높을 우선순위 부여

<br/>

4**) 우선순위 스케쥴링 (Priority Scheduling)**

→ 프로세스마다 우선순위 속성을 갖게 됨

→ 대기중인 프로세스들끼리 우선순위 비교후, 우선순위 높은 프로세스가 다음으로 진행

→ 우선순위 수치가 높을수록 우선순위가 높고, 우선순위가 같다면 FIFO방식으로 동작함

→ 기아현상(Starvation) 발생할 수 있음

<br/>

**5) 기안부 (Deadline)**

→ 프로세스가 사용할 수 있는 CPU의 시간을 정해주고 시간 안에 프로세스를 완료하도록 하는 기법

→ 주어진 시간을 초과했을 때, 프로세스는 제거되거나 처음부터 다시 실행( ⇒ 부담이 큰 기법)

<br/>

### 🔥 선점형 스케쥴링 알고리즘

---

**1) 라운드 로빈 스케쥴링(RR, Round Robin)**

→ FCFS를 선점형 기법으로 변환한 스케쥴링으로, 프로세스마다 같은 크기의 CPU 시간을 할당받아 
    균등한 CPU 점유 시간을 보장 (⇒ 공정한 스케쥴링 기법)

→ 프로세스가 할당된 시간 내에 작업을 완료하지 못했을 경우, 준비큐의 마지막으로 보내져 대기

→ 시분할 시스템을 위해 설계된 스케쥴링 기법

→ 할당시간이 너무 길면 FCFS와 같은 현상 발생

→ 할당시간이 너무 짧다면 문맥교환 자주 발생하여 오버헤드 발생 

<br/>

**2) 다단계 큐 스케쥴링 (Multi Level Queue)**

→ 프로세스들을 특정 그룹으로 분리하여, 각 그룹마다 독자적인 큐를 이용해서 스케쥴링 하는 기법

→ 특정그룹은 크게 사용자와 상호작용하는 전면작업과 후면작업으로 분리함 
    (프로세스 종류나 특성에 따라 여러개로 분할 가능)

→ 전면작업 큐에 프로세스들은 RR기법과 같은 효율적이고 빠른 실행 기법 사용

→ 후면작업 큐는 FCFS와 같은 기법으로 진행됨

→ 중요도에 따라 1차적으로 어떤 큐에 저장할지 우선순위 부여

    각 큐에서 다른 알고리즘이나 스케쥴링 기법을 통해 큐에 저장된 프로세스들의 우선순위 정함
    (⇒ 우선순위 처리에 대한 효율성 높일 수 있음)

→ 단점) 한번 큐에 들어가면 이동이나 변경 불가능으로 유연성 낮음

→ 장점) 오버헤드가 적게 발생함

<br/>

**3) 다단계 피드백 큐 스케쥴링 (Multi Level Feedback Queue)**

→ MLQ에 단점을 개선하여 서로 다른 큐로 이동할 수 있는 방식

→ 1차적으로 가장 중요한 작업인 프로세스들을 모아 큐에 넣음

→ 모아진 큐는 RR기법에 의해 스케쥴링되며, 완료하지 못했을 경우 다음 큐로 넘어감

→ 위 과정에서도 처리되지 못하였다면 가장 중요도가 낮다고 판단되는 큐에 최종적으로 들어가며
    FCFS기법으로 처리됨

→ RR기법의 할당 시간을 보고 우선순위를 예측하고 변경하면서 사용하는 기법
