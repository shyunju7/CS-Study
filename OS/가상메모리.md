### 가상 메모리 (Virtual Memory)


- 물리 메모리 한계를 극복하기 위해 나온 방법

- 물리 메모리와 논리 메모리를 분리하여 프로세스 전체가 메모리에 올라오지 않아도 실행가능하도록 하는 방법

- 실제 메모리 크기에 제약받지 않음

<br>

**💡 가상 메모리를 사용해야 하는 이유**

```
논리적으로 메모리 확장할 때 사용

물리 메모리 공간 파악할 필요 없이 사용 가능

메모리를 효율적으로 관리 가능
```

**1. 요구 페이징(Demanding Paging)**

- 특정 페이지 요청시, 메모리에 데이터를 적재하는 방법

- 적은 메모리 공간을 사용하여 구동할 수 있으며, 빠르게 응답할 수 있음

- 기존 페이지 테이블에서 `valid bit` 공간 추가

++ valid bit란, 현재 메모리에 페이지가 있는지 없는지를 나타내는 비트(존재한다면, 1 없다면 0)


<br>


**2. 페이지 부재(Page Fault)**

- CPU가 접근하려는 페이지가 메모리에 존재하지 않는 상태(valid bit : 0)

- 페이지 부재 처리 순서

    1) valid bit를 확인

    2) valid bit가 0이라면(invalid라면) CPU에 인터럽트 신호를 보내 ISR로 이동

    3) ISR(Interrupt Service Routine)에서 backing store(디스크) 탐색 및 페이지 찾음

    4) 찾은 페이지 빈 프레임에 할당

    5) 페이지 테이블 갱신

    6) 명령 실행

<br>

**Pure Demanding Paging**
```
프로세스가 최초로 실행될 때 어떤 페이지가 필요한지 알 수 없음으로 아무 페이지도 올리지 않음

첫 실행부터 Page Fault이 발생하여 속도 느림

메모리를 효율적으로 사용할 수 있음(필요한 페이지만 메모리에 올림으로)
```

<br>


**Prepaging**
```
실행될 때 필요할 것이라 판단되는 페이지를 미리 올려 놓는 방법

Page Fault 발생률이 적어 속도적으로 빠름

미리 올려둔 페이지를 미사용시 메모리 낭비
```

<br>

**3. 페이지 교체(Page replacement)**

- 물리 메모리가 모두 사용중일 때 페이지 교체가 나타남 
메모리에 있는 페이지 중 하나를 backing store(디스크)로 내보냄 -> page-out <br>
새로운 페이지를 메모리에 적재 -> page-in

- page-out된 페이지를 `희생양 페이지(Victim Page)`라고 함

- FIFO, 최적 페이지 교체, LRU, LFU등 페이지 교체 알고리즘이 존재 
